WGCNA
================
Jennifer Chang
1/8/2021

## Correlaion Network Analysis

-   [WGCNA
    Tutorial](https://bioinformaticsworkbook.org/tutorials/wgcna#gsc.tab=0)

## Install any required libraries

``` r
# == Install any CRAN packages
# cran_pkgs <- c("WGCNA")
# install.packages(cran_pkgs)

# == Install any Bioconductor packages
# bioc_pkgs <- c("DESeq2")
# BiocManager::install(bioc_pkgs)

# ====================   Year of development
library(tidyverse)
library(magrittr)
library(WGCNA)         # 2008    # <= originally developed for microarray data
library(DESeq2)        # 2014    # <= using this for normalization for now... can use any normalization program
```

# Load in normalized data

For now, we’ll do a quick normalization using DESeq2 but this should be
replaced with whichever normalization method preferred.

Load in the RNAseq counts generated by GSNAP.

``` r
data_maize <- read_delim("maize_genecounts.txt", delim = "\t")
#> 
#> ── Column specification ────────────────────────────────────────────────────────
#> cols(
#>   .default = col_double(),
#>   Geneid = col_character()
#> )
#> ℹ Use `spec()` for the full column specifications.
data_bee   <- read_delim("bee_genecounts.txt", delim="\t")
#> 
#> ── Column specification ────────────────────────────────────────────────────────
#> cols(
#>   .default = col_double(),
#>   Geneid = col_character()
#> )
#> ℹ Use `spec()` for the full column specifications.
```

## DESeq2 Normalization Methods

``` r
# === Convert to Matrix
de_input = as.matrix(data_bee[,-1])
row.names(de_input) = data_bee$Geneid
de_input[1:5,1:6]
#>                   1-A01-A1_S7 1-A02-A2_S8 1-A03-A3_S9 1-A04-A4_S10 1-A05-A5_S11
#> gene-LOC100740276          14           3          17           11            8
#> gene-LOC100740157         100         108         103           75           74
#> gene-LOC100742884         186         117         159          127          125
#> gene-LOC100740399          25          19          12            5           11
#> gene-LOC100740519         139          90          74           79           86
#>                   1-A06-A6_S12
#> gene-LOC100740276           21
#> gene-LOC100740157          102
#> gene-LOC100742884          120
#> gene-LOC100740399           20
#> gene-LOC100740519          118

# === Prepare Metadata
meta_df <- data.frame(Sample=names(data_bee[,-1])) %>%
  mutate(
     Condition = c(rep("ctrl", 18), rep("exposed", 8), rep("ctrl", 8), rep("exposed", 26)),
     Condition = factor(Condition, levels = c("ctrl", "exposed"))
     )
meta_df[1:5,]
#>         Sample Condition
#> 1  1-A01-A1_S7      ctrl
#> 2  1-A02-A2_S8      ctrl
#> 3  1-A03-A3_S9      ctrl
#> 4 1-A04-A4_S10      ctrl
#> 5 1-A05-A5_S11      ctrl

# === DESeq Normalization
dds <- DESeqDataSetFromMatrix(
  de_input,
  meta_df,
  design = ~Condition
)
#> converting counts to integer mode
dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
#> -- replacing outliers and refitting for 33 genes
#> -- DESeq argument 'minReplicatesForReplace' = 7 
#> -- original counts are preserved in counts(dds)
#> estimating dispersions
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#> 0.00000 0.03754 0.08041 0.09120 0.11777 4.14314

q_thresh <- quantile(rv_wpn, 0.75)                #<= reduced dataset here! Come back to reevaluate this threshold again
expr_normalized <- wpn_vsd[ rv_wpn > q_thresh,]
expr_normalized = wpn_vsd   # Entire dataset
dim(expr_normalized)
#> [1] 12925    60
```

# Start WGCNA

``` r
# Normalized expression (altho this is also thresholded)
expr_normalized[1:5,1:6]
#>                   1-A01-A1_S7 1-A02-A2_S8 1-A03-A3_S9 1-A04-A4_S10 1-A05-A5_S11
#> gene-LOC100740276    5.151316    4.683403    5.541407     5.207425     5.129134
#> gene-LOC100740157    6.681138    7.202371    7.211656     6.742070     6.911463
#> gene-LOC100742884    7.372009    7.295119    7.730224     7.329955     7.514336
#> gene-LOC100740399    5.495565    5.579992    5.318715     4.842332     5.304721
#> gene-LOC100740519    7.037015    6.996194    6.842649     6.797236     7.078312
#>                   1-A06-A6_S12
#> gene-LOC100740276     5.497213
#> gene-LOC100740157     6.890553
#> gene-LOC100742884     7.070505
#> gene-LOC100740399     5.464965
#> gene-LOC100740519     7.051619

wgcna_input = t(expr_normalized)      # WGCNA input is the transpose of DESeq2 output

allowWGCNAThreads()                   # multithreading
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  wgcna_input,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 3461.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 3461 of 12925
#>    ..working on genes 3462 through 6922 of 12925
#>    ..working on genes 6923 through 10383 of 12925
#>    ..working on genes 10384 through 12925 of 12925
#>    Power SFT.R.sq slope truncated.R.sq  mean.k. median.k. max.k.
#> 1      1   0.0099  0.20         -0.252 1650.000  1.65e+03 3760.0
#> 2      2   0.6720 -0.92          0.875  520.000  3.81e+02 1980.0
#> 3      3   0.7850 -1.33          0.881  217.000  1.08e+02 1230.0
#> 4      4   0.8020 -1.42          0.901  107.000  3.51e+01  834.0
#> 5      5   0.8020 -1.47          0.915   58.800  1.26e+01  594.0
#> 6      6   0.8290 -1.47          0.942   35.000  5.03e+00  439.0
#> 7      7   0.8360 -1.48          0.953   22.100  2.20e+00  333.0
#> 8      8   0.8430 -1.48          0.963   14.600  9.77e-01  258.0
#> 9      9   0.8520 -1.47          0.972    9.970  4.59e-01  203.0
#> 10    10   0.8600 -1.48          0.975    7.030  2.24e-01  162.0
#> 11    12   0.8830 -1.45          0.988    3.750  5.80e-02  107.0
#> 12    14   0.8920 -1.46          0.981    2.160  1.66e-02   72.8
#> 13    16   0.9090 -1.44          0.987    1.330  4.91e-03   51.1
#> 14    18   0.9160 -1.42          0.986    0.859  1.55e-03   36.7
#> 15    20   0.9190 -1.40          0.992    0.582  5.07e-04   27.5

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```

![](4_WGCNA_beesoftpower-1.png)<!-- -->

Maybe a power of 14 or 16.

``` r
picked_power = 16
temp_cor <- cor       
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(wgcna_input,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 30,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "temp",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#>  Calculating module eigengenes block-wise from all genes
#>    Flagging genes and samples with too many missing values...
#>     ..step 1
#>   ..Excluding 2166 genes from the calculation due to too many missing samples or zero variance.
#>     ..step 2
#>  ....pre-clustering genes to determine blocks..
#>    Projective K-means:
#>    ..k-means clustering..
#>    ..merging smaller clusters...
#> Block sizes:
#> gBlocks
#>    1    2    3 
#> 3994 3434 3331 
#>  ..Working on block 1 .
#>     TOM calculation: adjacency..
#>     ..will use 4 parallel threads.
#>      Fraction of slow calculations: 0.000000
#>     ..connectivity..
#>     ..matrix multiplication (system BLAS)..
#>     ..normalization..
#>     ..done.
#>    ..saving TOM for block 1 into file temp-block.1.RData
#>  ....clustering..
#>  ....detecting modules..
#>  ....calculating module eigengenes..
#>  ....checking kME in modules..
#>      ..removing 99 genes from module 1 because their KME is too low.
#>      ..removing 28 genes from module 2 because their KME is too low.
#>      ..removing 27 genes from module 3 because their KME is too low.
#>      ..removing 27 genes from module 4 because their KME is too low.
#>      ..removing 9 genes from module 6 because their KME is too low.
#>      ..removing 1 genes from module 8 because their KME is too low.
#>  ..Working on block 2 .
#>     TOM calculation: adjacency..
#>     ..will use 4 parallel threads.
#>      Fraction of slow calculations: 0.000000
#>     ..connectivity..
#>     ..matrix multiplication (system BLAS)..
#>     ..normalization..
#>     ..done.
#>    ..saving TOM for block 2 into file temp-block.2.RData
#>  ....clustering..
#>  ....detecting modules..
#>  ....calculating module eigengenes..
#>  ....checking kME in modules..
#>      ..removing 1 genes from module 1 because their KME is too low.
#>      ..removing 1 genes from module 2 because their KME is too low.
#>  ..Working on block 3 .
#>     TOM calculation: adjacency..
#>     ..will use 4 parallel threads.
#>      Fraction of slow calculations: 0.000000
#>     ..connectivity..
#>     ..matrix multiplication (system BLAS)..
#>     ..normalization..
#>     ..done.
#>    ..saving TOM for block 3 into file temp-block.3.RData
#>  ....clustering..
#>  ....detecting modules..
#>  ....calculating module eigengenes..
#>  ....checking kME in modules..
#>      ..removing 57 genes from module 1 because their KME is too low.
#>      ..removing 1 genes from module 2 because their KME is too low.
#>      ..removing 21 genes from module 3 because their KME is too low.
#>      ..removing 1 genes from module 4 because their KME is too low.
#>      ..removing 1 genes from module 5 because their KME is too low.
#>  ..merging modules that are too close..
#>      mergeCloseModules: Merging modules whose distance is less than 0.25
#>        Calculating new MEs...
```

Generate the Dendrogram and view modules

``` r
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```

![](4_WGCNA_beedendrogram-1.png)<!-- -->

Write modules to file

``` r
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>             gene_id colors
#> 1 gene-LOC100740276  green
#> 2 gene-LOC100740157   blue
#> 3 gene-LOC100742884   blue
#> 4 gene-LOC100740399   blue
#> 5 gene-LOC100740519   blue

write_delim(module_df,
            file = "bee_gene_modules.txt",
            delim = "\t")
```

Relate modules to treatment

``` r
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(wgcna_input, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

# TODO: swap in the meta data labels
mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```

![](4_WGCNA_beemoduletraits-1.png)<!-- -->
